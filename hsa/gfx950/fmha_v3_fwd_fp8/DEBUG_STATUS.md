# FP8 Scaffold Debug Status (2026-01-20)

Goal: document current kernel state, known-good parts, and open issues so we can resume without re-deriving context.

## Files in play
- `hsa/gfx950/fmha_v3_fwd_fp8/fwd_fp8_scaffold.s`
- `hsa/gfx950/fmha_v3_fwd_fp8/fwd_fp8_qk_debug.s`
- `hsa/gfx950/fmha_v3_fwd_fp8/test_qk_debug.py`
- `hsa/gfx950/fmha_v3_fwd_fp8/test_scaffold_numerics.py`
- `hsa/gfx950/fmha_v3_fwd_fp8/triton_fp8_fmha.s` (reference)

## Current kernel layout (scaffold)
- Q: pitch-132 LDS layout (row = tid>>1, col = (tid&1)*64), 2 tiles in LDS.
  - Q global load uses v32–v47 to avoid clobbering `lane_id` (v10) and `wave_id` (v9).
- K: row-major LDS, loaded by **explicit** `buffer_load_dwordx4` + `ds_write_b128`
  - Mask: `tid < 256`
  - LDS addr: `K_LDS{0,1} + (tid & 255) * 16`
  - Rationale: `buffer_load ... offen lds` with vaddr is invalid/unstable.
- V: swizzled LDS store (bitop3:0x78), TR8 reads in PV using bitop3:0x36 base + XOR variants.
- QK MFMA: `v_mfma_f32_32x32x64_f8f6f4`
- P packing: `v_cvt_pk_fp8_f32` + mask + `v_perm_b32` (Triton-style `v_cvt_scalef32_pk_fp8_f32` was tried and reverted).
- Half-wave P permute: currently **removed** (perf baseline); rowid still incorrect.

## Known-good parts
- QK debug (`fwd_fp8_qk_debug.s`) passes non-uniform random gate:
  - `DEBUG_RANDOM_NONUNIFORM=1` uses scaled inputs (0.05 * rand + 0.02)
  - Gate thresholds: max<=1.0, mean<=0.05, corr>=0.95
  - This validates pitch-132 Q + row-major K address mapping in the debug kernel.

## Current failures (scaffold)
Identity-P numerics:
- `NUMERICS_IDENTITY_P=1 NUMERICS_V_PATTERN=col`
  - **PASS** in decoded output for small block (rows/cols match).
- `NUMERICS_V_PATTERN=rowid`
  - **FAIL**: row permutation (even-row pattern); not a simple transpose.

Interpretation: PV path still wrong for rowid; likely **P-to-A layout/transpose** mismatch, possibly V TR8 base.

## PV B-operand mapping (2026-01-23)
New diagnostics were added to isolate the PV B-operand layout after Triton mix:
- Report: `hsa/gfx950/fmha_v3_fwd_fp8/pv_b_mapping_report.md`
- Source: `p_pack_mapping.csv` generated by `test_p_pack_map.py`

Key findings:
- **Row LSB is preserved in byte parity**: `(src_byte & 1) == (row & 1)` for 1023/1024 entries.
- **Diagonal mapping is lane-shifted**:
  - `row=k=0` lands at `lane 63, pos 31`.
  - `row=k=16..31` lands at `lane 48..63, pos 0..15`.
- This indicates the current mix preserves row parity in bytes but **MFMA B expects a different byte/lane placement**, so row LSB is effectively dropped in output.

Next focus:
1. Use the report to derive a cross-register byte permutation for `v48..v55`.
2. Apply the permutation post-mix and re-test `NUMERICS_IDENTITY_P=1` with `rowid` + `col`.

## MFMA K=64 mapping verified (2026-01-24)
`test_mfma_map_debug.py` exhaustively searched k-range mappings and matched hardware with zero error:
- Lane group 0/2: reg0–3 → k16–31, reg4–7 → k0–15
- Lane group 1/3: reg0–3 → k48–63, reg4–7 → k32–47

This is now recorded as a proven fact in `.domain`.

## Raw P-pack mapping formula (mix disabled)
Using `fwd_fp8_p_pack_dump.s` with the mix skipped, the raw packed P layout follows:
- `src_reg = row >> 3`
- `src_byte = row & 3`
- `src_lane = k + 32 * ((row >> 2) & 1)` for k=1..31
- Special case: row0,k0 → lane63 reg7 byte3

Implication: each desired B dword pulls bytes from **four different source lanes**; a simple lane-only or byte-only permute cannot fix this.

## PV A-operand mapping (V LDS reads)
Using the new probe `fwd_fp8_v_read_dump.s` + `test_v_read_map.py`, the current V LDS read pattern maps rows as `row>>1` for lanes 0..7 (rows duplicate in pairs). This matches the observed identity-P rowid failure and confirms the A operand (V) mapping is dropping row LSB.

## PV A base debug (row-mapped)
Replacing the TR8 base with an explicit row-mapped base in `fwd_fp8_scaffold.s` restores identity-P rowid (rows 0..7 correct). This confirms the TR8 base swizzle is the source of the row-LSB loss; col still mismatches due to B layout and missing K offsets in this debug path.

Next: derive MFMA A-side K-offset mapping for K=64 and rebuild PV A reads (row-mapped base + correct K offsets) to validate full PV.

## PV A TR8 mapping gap
`v_read_mapping.csv` (from `test_v_read_map.py`) shows TR8 PV A reads only hit k values with bit2=0: {0..3,8..11,16..19,24..27}. This explains the persistent row>>1 behavior when using the current TR8 base/offset scheme.

Col-coded probe update: when V encodes columns, TR8 reads only see column codes 0 and 16 (bit4 toggling). This confirms the TR8 base/offset scheme collapses column bits and cannot reach full k without a layout/base change.

## Recent findings (2026-01-23)
- Added raw-byte A/B dump in `test_scaffold_a_dump.py` and MFMA replay in `test_mfma_from_pv_dump.py`.
- A regs show rows 1–3 mapped (pos17–19) but row0 is missing (lane0 A all zeros).
- B lane>=32 mapping is wrong: lane32 pos16..19 = 4..7 (should be 0..3). This corrupts rows 4+.
- MFMA replay confirms output col0 uses B lane0; lane>=32 mapping must be rebuilt (mirroring lanes is insufficient).
- Row mapping should be `row = lane & 31` for identity-P rowid (row0 output zeros with current mapping).

Next:
1. Recompute row0 A mapping from raw P-pack bytes (post-transpose).
2. Rebuild lane>=32 B mapping using the verified k-range bases.

## Perf note
- Current benchmark ~33.3 ms (~0.65 PF eq) because GPU0 sclk is stuck at ~150MHz (DPM level 1). Attempts to raise sclk via `rocm-smi` failed (manual/perf determinism not permitted).

## Recent adjustments (summary)
- **K preload rewrite**: replaced `buffer_load ... offen lds` with
  - `buffer_load_dwordx4 v[20:23], v_offset, s[12:15], 0 offen`
  - `ds_write_b128` into K_LDS0/1
  - This fixed the K preload reliability but did not fix PV numerics.
- **P packing**: reverted to `v_cvt_pk_fp8_f32` + mask + `v_perm_b32`.
- **Q load fix**: moved Q loads to v32–v47 to preserve `lane_id`/`wave_id`; QK identity now correct inside scaffold.
- **P permute**: several `ds_bpermute` variants tried; adjacent-pair permute keeps col-pattern correct but rowid still wrong.

## Repro commands
Build:
```
/opt/rocm/llvm/bin/clang -x assembler -target amdgcn-amd-amdhsa -mcpu=gfx950 -mno-xnack \
  -c hsa/gfx950/fmha_v3_fwd_fp8/fwd_fp8_scaffold.s -o hsa/gfx950/fmha_v3_fwd_fp8/fwd_fp8_scaffold.o && \
/opt/rocm/llvm/bin/ld.lld -shared hsa/gfx950/fmha_v3_fwd_fp8/fwd_fp8_scaffold.o \
  -o hsa/gfx950/fmha_v3_fwd_fp8/fwd_fp8_scaffold.co
```

QK debug gate:
```
DEBUG_RANDOM_NONUNIFORM=1 python hsa/gfx950/fmha_v3_fwd_fp8/test_qk_debug.py
```

Identity-P PV checks:
```
NUMERICS_IDENTITY_P=1 NUMERICS_V_PATTERN=col python hsa/gfx950/fmha_v3_fwd_fp8/test_scaffold_numerics.py
NUMERICS_IDENTITY_P=1 NUMERICS_V_PATTERN=rowid python hsa/gfx950/fmha_v3_fwd_fp8/test_scaffold_numerics.py
```

## Next focus (priority)
1. **Derive correct P-to-A transpose**:
   - Use LDS transpose or port Triton’s exact `ds_bpermute`/`cndmask` sequence.
2. **Verify TR8 V base vs Triton**:
   - Compare `bitop3:0x36 + XOR` base set and `lane_id` usage.
3. **PV-only debug path**:
   - Dump packed P (v48–v55) and/or V TR8 reads to validate operand layouts.

