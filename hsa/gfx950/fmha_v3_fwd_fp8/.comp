# FP8 Flash Attention - BF16 Comparison

## Reference Kernel
`hsa/gfx950/fmha_v3_fwd/fwd_hd128_bf16.s`

---

## Key Architecture Difference (CORRECTED)

### BF16 Reference: 128 Q Rows, 4 Waves × 32 Each
```
Wave 0: Q[0:31]   → S[0:31, :]   → O[0:31, :]
Wave 1: Q[32:63]  → S[32:63, :]  → O[32:63, :]
Wave 2: Q[64:95]  → S[64:95, :]  → O[64:95, :]
Wave 3: Q[96:127] → S[96:127, :] → O[96:127, :]
```

### Current FP8: 32 Q Rows, 1 Wave
```
Wave 0: Q[0:31] → S[0:31, :] → O[0:31, :]
Waves 1-3: Idle (fwd_fp8_256t_min.s) or not launched (fwd_fp8_kloop.s)
```

### Gap: 4× Q rows, 4× parallelism

---

## Hardware Constraint: MFMA 32×32 Only

On gfx950, FP8 MFMA has ONE size:
```
v_mfma_f32_32x32x16_fp8_fp8  →  32×32 output minimum
```

No 8×8, 16×16, or 4×4 variants exist!

**Implication**: Each wave MUST process 32 complete rows (full MFMA tile).

---

## Same Patterns as BF16 ✅

| Feature | BF16 | FP8 |
|---------|------|-----|
| S^T = K @ Q^T | ✅ | ✅ |
| Row-wise softmax | permlane32_swap | Same |
| Buffer descriptor | s10=size, s11=0x20000 | Same |
| Online softmax | running_max, running_sum | Same |
| O rescaling | correction * O | Same |
| Final norm | O / running_sum | Same |

---

## Different from BF16

| Aspect | BF16 | FP8 |
|--------|------|-----|
| MFMA | `v_mfma_f32_32x32x8_bf16` | `v_mfma_f32_32x32x16_fp8_fp8` |
| Element size | 2 bytes | 1 byte |
| K per MFMA | 8 | 16 |
| Passes for HD=128 | 16 | 8 |
| FP8 conversion | N/A | `v_cvt_pk_fp8_f32` for P |

---

## Implementation Path

### Current (Working)
- 32 Q rows per workgroup
- 64 threads (1 wave)
- ~150 TF/s

### Target
- 128 Q rows per workgroup  
- 256 threads (4 waves)
- >1300 TF/s (30% over BF16)

### Steps
1. Increase Q tile from 32 to 128 rows
2. Each wave loads its 32 Q rows to LDS
3. All waves cooperate to load K/V tiles
4. Each wave computes independently (softmax is row-wise)
5. Each wave stores its 32 output rows

---

## LDS Budget (64KB on MI350)

| Region | Current (32 Q) | Target (128 Q) |
|--------|----------------|----------------|
| Q | 4KB | 16KB |
| K tile | 4KB | 4KB |
| V tile | 4KB | 4KB |
| P per wave | 4KB | 4×4KB = 16KB |
| Total | 16KB | 40KB |
| Available | 64KB | 64KB |

Plenty of headroom for 128 Q rows!

---

## Discovered Bugs (Fixed)

### 1. VGPR Offset Recalculation in K-loop
Must recalculate `v1 = tid * 16` at start of each K-tile loop iteration.

### 2. Buffer Descriptor Size = -1 for Multi-tile
For K-loop to access beyond first tile, size must be -1 (max), not 4096.

### 3. v_cvt_pk_fp8_f32 Garbage in High Bits
Always mask with `v_and_b32 v, 0xFFFF, v` before combining packed values.

### 4. AGPR Write Timing
Write AGPRs immediately before MFMA, after V packing (not before V read).

---

## Test Results

```
seq_len=32  (1 tile):  max_error=0.088 ✅
seq_len=64  (2 tiles): max_error=0.073 ✅
seq_len=96  (3 tiles): max_error=0.060 ✅
seq_len=128 (4 tiles): max_error=0.066 ✅
seq_len=256 (8 tiles): max_error=0.043 ✅
```

Multi-tile errors generally DECREASE (proper accumulation verified).
