# FP8 Flash Attention - BF16 Comparison

## Reference Kernel
`hsa/gfx950/fmha_v3_fwd/fwd_hd128_bf16.s`

---

## Key Patterns from BF16 (Must Follow)

### 1. Buffer Descriptor Setup
```asm
// BF16 pattern
s_load_dwordx2 s[8:9], s[0:1], 0x08   // Load base address
s_mov_b32 s10, 4096                    // Size
s_mov_b32 s11, 0x20000                 // Flags (offen mode)
```
**FP8 Status**: ✅ Same pattern used

### 2. K-tile Offset Management
```asm
// BF16 K-loop pattern
s_mov_b32 s34, 0                       // K offset starts at 0
s_mul_i32 s43, 64, s47                 // K stride = 64 * stride_param
...
buffer_load_dwordx4 v4, s[12:15], s34 offen lds
s_add_i32 s34, s43, s34                // Advance to next tile
```
**FP8 Status**: ✅ Same pattern
- `s27` = K offset (starts at 0)
- `s26` = K stride (4096 bytes = 32 rows × 128 cols × 1 byte)
- `s_add_i32 s27, s27, s26` advances offset

### 3. Online Softmax State
```asm
// BF16 maintains across K-tiles:
v_mov_b32_e32 v24, 0xff7fffff          // running_max = -large
v_mov_b32_e32 v16, 0                   // running_sum = 0
// v[96:159] = O accumulator
```
**FP8 Status**: ✅ Same pattern
- `v70` = running_max (init to 0xff800000 = -inf)
- `v71` = running_sum (init to 0)
- `v[80:95]` = O accumulator (first 32 HD cols)

### 4. Correction Factor
```asm
// When new tile has larger max:
v_sub_f32_e32 v16, v_old_max, v_new_max
v_mul_f32_e32 v16, s37, v16            // * log2(e)/sqrt(d)
v_exp_f32_e32 v16, v16                 // correction = exp(...)
// Apply to O accumulator:
v_mul_f32_e32 v110, v16, v110
```
**FP8 Status**: ✅ Same pattern
```asm
v_sub_f32_e32 v23, v70, v22            // old_max - new_max
v_mul_f32_e32 v23, s2, v23             // * scale
v_exp_f32_e32 v23, v23                 // correction
v_mul_f32_e32 v80, v80, v23            // rescale O
```

### 5. V1 Recalculation Before K Load
**Critical Fix**: BF16 kernel sets VGPR offset before each buffer_load block.
FP8 must recalculate `v1 = tid * 16` before K load in loop:
```asm
K_TILE_LOOP:
    v_lshlrev_b32_e32 v1, 4, v0        // MUST recalculate!
    buffer_load_dwordx4 v1, s[12:15], s20 offen lds
```

---

## FP8 Implementation Status

### Same as BF16 ✅
| Feature | BF16 | FP8 |
|---------|------|-----|
| S^T = K @ Q^T | ✅ | ✅ |
| Row-wise softmax | VGPR sum + permlane32_swap | Same |
| Buffer descriptor | s10=size, s11=0x20000 | Same |
| Scalar offset | buffer_load with soff | Same |
| Online softmax | running_max, running_sum | Same |
| O rescaling | correction * O | Same |
| Final norm | O / running_sum | Same |

### Different from BF16
| Aspect | BF16 | FP8 |
|--------|------|-----|
| MFMA | `v_mfma_f32_32x32x16_bf16` | `v_mfma_f32_32x32x16_fp8_fp8` |
| Operand size | 4 VGPRs (8 BF16) | 2 VGPRs (8 FP8) |
| Element size | 2 bytes | 1 byte |
| FP8 conversion | N/A | `v_cvt_pk_fp8_f32` before PV MFMA |
| P storage | Direct to MFMA | F32 → LDS → FP8 |

---

## Discovered Bugs (Fixed)

### 1. `.args` Metadata Required
FP8 kernels MUST include explicit `.args:` section in `.amdgpu_metadata`:
```yaml
.amdgpu_metadata
---
amdhsa.kernels:
  - .name: kernel_name
    .args:
      - {.name: ptr_O, .size: 8, .offset: 0, .value_kind: global_buffer, .address_space: global}
      - {.name: ptr_Q, .size: 8, .offset: 8, .value_kind: global_buffer, .address_space: global}
      ...
```
**Symptom**: Memory fault at address (nil)
**Cause**: Without `.args`, HIP runtime can't pass kernel arguments correctly
**Note**: BF16 kernel has this from original compilation

### 2. VGPR Offset Must Be Recalculated (Critical Bug)
The `v1` register (per-thread offset for buffer_load) must be recalculated before each K-tile load inside the loop.
```asm
K_TILE_LOOP:
    v_lshlrev_b32_e32 v1, 4, v0        // MUST recalculate here!
    buffer_load_dwordx4 v1, s[12:15], s20 offen lds
```
**Symptom**: Output is all zeros (computation completely wrong, not precision issue)
**Cause**: v1 was set once for Q load, became stale by K load time
**Fix**: Add `v_lshlrev_b32_e32 v1, 4, v0` at start of K_TILE_LOOP

### 3. Buffer Descriptor Size Must Be Max (Critical Bug)
The buffer descriptor size field must be -1 (max) for multi-tile access with scalar offsets.
```asm
// WRONG - limits access to first 4096 bytes
s_mov_b32 s14, 4096       // K buffer size
s_mov_b32 s18, 4096       // V buffer size

// CORRECT - allows full buffer access
s_mov_b32 s14, -1         // K buffer size = max
s_mov_b32 s18, -1         // V buffer size = max
```
**Symptom**: Only tile 0 data used; output is 1/N of expected for N tiles
**Cause**: With size=4096, `s27=4096` offset for tile 1 exceeds bounds → returns 0
**Fix**: Set buffer descriptor size to -1 (max) for K and V

### 4. F32/FP8 Running Sum Consideration
- `running_sum` computed from F32 P values
- `O` computed from FP8 P @ FP8 V
- Small precision difference in final `O / running_sum`
**Result**: ~0.09-0.18 max error depending on tile count

---

## LDS Layout Comparison

| Region | BF16 (~32KB) | FP8 (12KB) |
|--------|--------------|------------|
| Q | offset 0 | offset 0 (4KB) |
| K | offset ~8KB | offset 4096 → P reuse |
| V | loaded per-tile | offset 8192 (4KB) |
| P | in registers | offset 4096 (overwrites K) |

---

## Test Results (After Buffer Descriptor Fix)

```
seq_len=32  (1 tile):  max_error=0.088 ✅
seq_len=64  (2 tiles): max_error=0.073 ✅
seq_len=96  (3 tiles): max_error=0.044 ✅
seq_len=128 (4 tiles): max_error=0.035 ✅
```

Note: Multi-tile errors now DECREASE with more tiles (proper accumulation).

---

## Debug Tools

### 1. Assembly Validator (`asm_validator.py`)
Static analysis to detect common issues:
```bash
python asm_validator.py fwd_fp8_kloop.s
```
Detects:
- Buffer descriptor size limits
- VGPR not recalculated in loops
- Missing barriers

### 2. Runtime Parameter Validator
Pre-launch check for buffer overflow:
```python
from asm_validator import validate_kernel_params
validate_kernel_params(seq_len=128, k_buffer_size=4096)  # Will warn!
```

### 3. Debug Harness (`debug_harness.py`)
Comprehensive kernel testing:
```bash
python debug_harness.py fwd_fp8_kloop.s
```
Tests:
- V=1 identity (output should be 1.0)
- Tile isolation (each tile contributes)
- Accumulation check (sum of isolated = full)
- Element ratio consistency (detects addressing bugs)

### 4. BF16 Baseline Test (`test_bf16_baseline.py`)
Validates testing methodology against known-working BF16 kernel:
```bash
python test_bf16_baseline.py
```

**Comparison (BF16 vs FP8):**
| Metric | BF16 | FP8 | Notes |
|--------|------|-----|-------|
| V=1 identity | 1.0000 | ~1.01 | FP8 quantization |
| Reference max_err | 0.001 | 0.03-0.09 | Expected precision diff |
| Ratio consistency std | 0.003 | 0.18-0.27 | FP8 noise |

BF16 passes all tests → validates our methodology is correct
