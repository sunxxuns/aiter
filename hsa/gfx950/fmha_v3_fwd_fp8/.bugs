# Common Assembly Bugs Reference

## Buffer Descriptor Issues

### 1. Size Field Too Small
**Symptom**: Only tile 0's data used, output is 1/N of expected for N tiles
**Cause**: Buffer descriptor size limits access range
```asm
// WRONG
s_mov_b32 s14, 4096       // Size = one tile

// CORRECT  
s_mov_b32 s14, -1         // Size = unlimited (0xFFFFFFFF)
```
**Detection**: 
- Output elements have wildly different ratios to reference
- Tile isolation test shows tile 1+ outputs as 0

### 2. Descriptor Registers Overwritten
**Symptom**: Memory access faults or wrong data
**Cause**: Later code overwrites descriptor setup
```asm
// Setup
s_mov_b32 s14, -1         // K size

// Later code accidentally overwrites s14
s_mov_b32 s14, 4096       // OOPS! Changed K size
```
**Prevention**: Document which SGPRs are reserved for descriptors

---

## VGPR Staleness

### 3. VGPR Not Recalculated in Loop
**Symptom**: Output is zeros or only first tile processed
**Cause**: VGPR used as offset was set before loop, becomes stale
```asm
v_lshlrev_b32_e32 v1, 4, v0    // Set before loop

K_TILE_LOOP:
    // v1 used here but may have been clobbered
    buffer_load_dwordx4 v1, s[12:15], s20 offen lds
    // ... loop body modifies v1 ...
    s_cbranch_scc1 K_TILE_LOOP
```
**Fix**: Recalculate VGPR at loop start
```asm
K_TILE_LOOP:
    v_lshlrev_b32_e32 v1, 4, v0    // Recalculate!
    buffer_load_dwordx4 v1, s[12:15], s20 offen lds
```

---

## Synchronization

### 4. Missing Barrier After LDS Store
**Symptom**: Random incorrect values, works sometimes
**Cause**: Race condition between threads
```asm
// WRONG
ds_write_b32 v8, v10
ds_read_b32 v11, v8     // Race! Other threads may not have written yet

// CORRECT
ds_write_b32 v8, v10
s_waitcnt lgkmcnt(0)
s_barrier               // Sync all threads
ds_read_b32 v11, v8
```

### 5. Wrong Waitcnt Type
**Symptom**: Data not ready when used
**Cause**: Using wrong counter
```asm
// buffer_load to LDS uses vmcnt, not lgkmcnt
buffer_load_dwordx4 v1, s[8:11], 0 offen lds
s_waitcnt lgkmcnt(0)    // WRONG! This waits for ds_ ops
s_waitcnt vmcnt(0)      // CORRECT for buffer_load
```

---

## Online Softmax

### 6. Using tile_max Instead of new_max
**Symptom**: Multi-tile output scaled wrong, ratios vary per tile
**Cause**: P computed with local max instead of global max
```asm
// WRONG
v_sub_f32_e32 v23, v32, v21    // S - tile_max
v_mul_f32_e32 v23, s2, v23
v_exp_f32_e32 v32, v23         // P = exp((S - tile_max) * scale)

// CORRECT
v_sub_f32_e32 v23, v32, v22    // S - new_max (global max)
v_mul_f32_e32 v23, s2, v23
v_exp_f32_e32 v32, v23         // P = exp((S - new_max) * scale)
```

---

## Debug Strategies

### Quick Checks
1. **V=1 test**: Output should be ~1.0 (sum of softmax)
2. **Tile isolation**: Set V=0 except one tile, check if that tile contributes
3. **Element ratios**: kernel/reference ratios should be consistent (~1.0)

### Systematic Debug
1. Start with 1 tile (should work)
2. Add 2nd tile, check if both contribute
3. Check buffer descriptor sizes allow multi-tile access
4. Check VGPR offsets recalculated in loop
5. Check barriers between LDS store and read

### Tools
```bash
# Static analysis
python asm_validator.py kernel.s

# Runtime validation
python debug_harness.py kernel.s

# Parameter check before launch
python -c "from asm_validator import validate_kernel_params; validate_kernel_params(128, 4096, 4096)"
```
