###############################################################################
# FP8 FLASH ATTENTION ASM KERNEL PROJECT
###############################################################################

# ON FIRST MESSAGE: Print this to confirm rules loaded:
instrution loaded: FP8 FMHA ASM v2025-01-18"

## TARGET
- Write FP8 flash attention ASM kernel for gfx950
- Target: >1300 TF/s (30%+ faster than BF16's 1016 TF/s)
- Benchmark shape: B=1, H=40, S=32130, D=128
- Reference: /sgl-workspace/aiter/hsa/gfx950/fmha_v3_fwd/fwd_hd128_bf16.s

## CONSTRAINTS
- Final deliverable: .s assembly file in this repo (no runtime CK/Triton)
- Follow BF16 kernel strategy (online softmax, tiled attention)
- FP8 format: e4m3fn (1-4-3), per-tensor scaled
- CK-generated asm allowed as REFERENCE only, not as final solution

###############################################################################
# PING-PONG COLLABORATIVE DEBUGGING PROTOCOL
###############################################################################

## TWO MODELS

### CODE MODEL
- Trigger: "You are the code model"
- Role: Write assembly, run tests, implement fixes
- Writes to: `.code` (summary of EVERY turn), `.path` files (current approach)
- Reads from: `.domain` (proven facts), `.lessons` (HW knowledge)
- GPU: 0 (HIP_VISIBLE_DEVICES=0)

**CODE MODEL TURN TEMPLATE** (append to .code every turn):
```
=== TURN [timestamp] ===
ACTION: [what I did]
RESULT: [pass/fail + key numbers]
INSIGHT: [what I learned]
NEXT: [immediate next step]
BLOCKER: [if stuck, specific question for domain model]
```

### DOMAIN MODEL
- Trigger: "You are the domain model"
- Role: Research, analyze, provide proven facts
- Writes to: `.domain` (ONLY proven facts with evidence)
- Reads from: `.code` (code model's log), BF16 reference, ISA docs
- GPU: 7 (HIP_VISIBLE_DEVICES=7)

**DOMAIN MODEL OUTPUT TEMPLATE**:
```
=== PROVEN FACT: [name] ===
CLAIM: [precise statement]
EVIDENCE: [file:line or test result]
FORMULA: [if applicable]
```

## WORKFLOW
1. Code model works → logs to .code every turn
2. Code model hits blocker → writes specific question in .code
3. User triggers domain model
4. Domain model reads .code → researches → writes PROVEN FACTS to .domain
5. User triggers code model
6. Code model reads .domain → applies proven facts → continues

###############################################################################
# SINGLE PATH TRACKING
###############################################################################

At any time there is ONLY ONE active approach per problem being worked on.

## PATH FILES (*.path)

Create a `.path` file for any component/problem being actively worked on.
Name it descriptively: `<component>.path` or `<problem>.path`

Examples:
- `multiblock.path` - Adding multi-block grid support
- `lds_swizzle.path` - Implementing bank-conflict-free LDS layout
- `kloop_pipeline.path` - Overlapping K-tile loads with compute
- `p_redistribution.path` - Fixing P matrix layout for PV MFMA

**PATH FILE FORMAT**:
```
STATUS: [exploring|testing|proven|abandoned]
APPROACH: [one-line description]
KEY_PARAMS: [specific values, formulas, constants]
TEST_RESULT: [last test: PASS/FAIL + key numbers]
NEXT_STEP: [immediate action]
ABANDONED_REASON: [only if STATUS=abandoned]
```

**RULES**:
- ONE active path per problem (don't explore multiple approaches simultaneously)
- When switching approaches: set STATUS=abandoned with reason, create new .path
- When approach works: set STATUS=proven, document in .lessons if HW-related
- Delete old .path files when no longer relevant

###############################################################################
# KEY FILES
###############################################################################

## STATUS FILES
- `.code` - Code model's turn-by-turn log (append-only during session)
- `.domain` - Domain model's proven facts (curated, verified)
- `.lessons` - HW knowledge (layouts, errors, ISA quirks) - see below
- `.milestone` - High-level project status and roadmap

## PATH FILES
- `*.path` - Current approach for each component (see above)

## REFERENCE FILES
- `hsa/gfx950/fmha_v3_fwd/fwd_hd128_bf16.s` - BF16 reference kernel
- `hsa/gfx950/fmha_v3_fwd_fp8/*.s` - FP8 kernel development

###############################################################################
# .lessons FILE STRUCTURE
###############################################################################

Focus ONLY on hardware knowledge that prevents repeated mistakes:

## Categories:
1. LDS LAYOUT - pitch, swizzle formulas, bank conflict rules
2. MFMA MAPPING - input packing, output fragment layout
3. MEMORY OPS - buffer_load quirks, waitcnt rules
4. REGISTER HAZARDS - VGPR conflicts, SGPR clobbers
5. DEBUG TECHNIQUES - how to extract values, common traps

## Format:
```
### [CATEGORY]: [Title]
SYMPTOM: [what goes wrong]
CAUSE: [why]
FIX: [what to do]
EXAMPLE: [code snippet if helpful]
```

DO NOT put in .lessons:
- Strategy decisions (those go in .path files)
- Session-specific debugging notes (those go in .code)
- Unverified hypotheses (those stay in .domain until proven)

###############################################################################
# BENCHMARKING
###############################################################################

Command: `python /sgl-workspace/sglang/benchmark/kernels/bench_mi350_fmha_asm.py --seq-len 32130`

Grid size MUST be full:
```
grid_x = ceil(S / Q_rows_per_block)  # Q-tiles
grid_y = B * H                        # batch × heads
```

FLOPs: `4 * B * H * S * S * D` (full attention)

Single-block benchmarks are INVALID for TF/s measurement.

###############################################################################
# PROFILING WITH ROCPROF
###############################################################################

Use rocprof to identify bottlenecks. Key metrics for MFMA kernels:
also refer to  ../rocprof-compute-viewer

## Quick Profile (timing only)
```bash
rocprof --stats python test.py
```

## LDS Bank Conflicts
```bash
rocprof -i metrics.txt python test.py
# metrics.txt:
pmc: SQ_LDS_BANK_CONFLICT
```

## Memory vs Compute Bound
```bash
# metrics.txt:
pmc: GRBM_COUNT, GRBM_GUI_ACTIVE
pmc: SQ_WAVES, SQ_INSTS_VALU, SQ_INSTS_LDS
pmc: TCC_HIT, TCC_MISS, TCC_EA_RDREQ, TCC_EA_WRREQ
```

## MFMA Utilization
```bash
# metrics.txt:
pmc: SQ_INSTS_VALU_MFMA
```

## Common Bottlenecks
| Symptom | Metric | Cause | Fix |
|---------|--------|-------|-----|
| Low TF/s | High SQ_LDS_BANK_CONFLICT | LDS stride = 128 | Use stride 132/136 |
| Low TF/s | Low SQ_INSTS_VALU_MFMA | Memory stalls | Pipeline loads |
| Low TF/s | High TCC_MISS | Poor cache reuse | Tile for L2 |

## Profile Single Kernel
```bash
HIP_VISIBLE_DEVICES=0 rocprof --stats -o profile.csv python test.py
# Check profile.csv for kernel duration
```

###############################################################################
# CRITICAL RULES
###############################################################################

1. **Never use flat_load/flat_store** - always buffer_load/buffer_store
2. **Always set HIP_VISIBLE_DEVICES** before GPU code
3. **Log every turn** in .code (code model)
4. **Only proven facts** go in .domain (domain model)
5. **One path at a time** - track in .path files
6. **struct.unpack for uint32** in float32 debug buffers

###############################################################################
# FILE MODIFICATION RULES
###############################################################################

- `.code` - Code model appends freely during session
- `.domain` - Domain model writes proven facts only
- `.path` - Either model updates current approach status
- `.lessons` - Requires user approval (HW knowledge only)
- `.milestone` - Requires user approval
- `.cursorrules` - Requires user approval
